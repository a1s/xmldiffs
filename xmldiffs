#!/usr/bin/env python
"""Compare two XML files, ignoring element and attribute order

Copyright (c) 2017, Johannes H. Jensen.
License: BSD, see LICENSE for more details.

"""
from __future__ import print_function, unicode_literals
import argparse
import difflib
import sys
import os
import io
import xml.etree.ElementTree as ET
from tempfile import NamedTemporaryFile
import subprocess
from textwrap import dedent

def attr_str(k, v):
    return "{}=\"{}\"".format(k,v)

def node_str(n):
    attrs = sorted(n.attrib.items())
    astr = " ".join(attr_str(k,v) for k,v in attrs)
    s = n.tag
    if astr:
        s += " " + astr
    return s

def node_key(n):
    return node_str(n)

def sort_xml(node, level=0):
    """Return a list of text lines from an I{ElementTree} node

    @param node: an C{Element} object containing XML data.
    @param level: text indentation level.

    """
    indent = "  "
    children = node.getchildren()
    text = (node.text or "").strip()
    tail = (node.tail or "").strip()
    out = []

    if children or text:
        children.sort(key=node_key)

        node_start = "%s<%s>" % (indent, node_str(node))

        if text and len(children) == 0:
            line_length = len(node_start) + len(text) + 1 + len(node.tag) + 1
            if line_length < 120:
                out.append("%s%s</%s>\n" % (node_start, text, node.tag))
            else:
                out.append(node_start)
                out.append("%s%s\n" % (indent, text))
                out.append("%s</%s>\n" % (indent, node.tag))

        else:
            out.append(node_start)
            if text:
                out.append("%s%s\n" % (indent, text))
            for child in sorted(children, key=node_key):
                out.extend(sort_xml(child, level+1))
            out.append("%s</%s>\n" % (indent, node.tag))
    else:
        out.append("%s<%s/>\n" % (indent, node_str(node)))

    if tail:
        out.append("%s%s\n" % (indent, tail))

    return out

def write_list(stream, lines, encoding="utf-8"):
    """Write a sequence of Unicode lines to a binary output stream

    @param stream: An open file-like object.
    @param lines: A sequence of binary strings to write. Must include newlines.
    @param encoding: Optional character encoding. (Default: UTF-8.)

    """
    stream.write("".join(lines).encode("utf-8"))

def xmldiffs(file1, file2, diffargs=["-u"]):
    """Execute the C{diff} command on two files, return I{stdout} contents"""
    tree = ET.parse(file1)
    tmp1 = NamedTemporaryFile()
    write_list(tmp1, sort_xml(tree.getroot()))
    tmp1.flush()

    tree = ET.parse(file2)
    tmp2 = NamedTemporaryFile()
    write_list(tmp2, sort_xml(tree.getroot()))
    tmp2.flush()

    args = [ "diff" ]
    args += diffargs
    args += [ "--label", file1, "--label", file2 ]
    args += [ tmp1.name, tmp2.name ]

    return subprocess.call(args)

def parse_commandline(args):
    """Return command options filled from command line

    @rtype: C{argparse.Namespace}
    @return: An object with the following attributes:

        file - a tuple containing two file names.
        diffargs - additional options from the command line.

    """
    parser = argparse.ArgumentParser(
        description=dedent("""\
            Compare two XML files, ignoring element and attribute order."""),
        epilog=dedent("""\
            Any extra options are passed to the `diff' command.

            Copyright (c) 2017, Johannes H. Jensen.
            License: BSD, see LICENSE for more details.
            """))
    parser.add_argument("file", nargs=2, metavar="FILE",
        help="an xml file to compare")
    (options, diffargs) = parser.parse_known_args(args)
    options.diffargs = diffargs
    return options

def run(args):
    options = parse_commandline(args[1:])
    exit(xmldiffs(*options.file, diffargs=options.diffargs or ["-u"]))

if __name__ == '__main__':
    run(sys.argv)
